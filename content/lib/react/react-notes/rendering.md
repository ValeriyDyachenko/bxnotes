---
title: Руководство по рендеренгу в React
description: Как React рендерит компоненты, оптимизация и тонкости рендеринга, отличие Контекста и React-Redux.
keywords: react, rendering
date: 2020-06-13 00:00:00
origin: <a rel="nofollow" href="https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/" target="_blank">A (Mostly) Complete Guide to React Rendering Behavior</a>
---

## Обновление UI

> Render не перерисовывает DOM дерево, его задача &mdash; формирование "виртуального" дерева. Если полученное дерево совпадает с предыдущим, то обновления DOM не произойдет.

Процесс обновления UI в React приложении состоит из трех фаз:

1. *Render* &mdash; формирование текущего дерева компонентов на основании их свойств (props) и состояния (state)

2. *Reconciliation* &mdash; сравнение и вычисление отличий с предыдущим деревом

3. *Commit* &mdash; обновление DOM

После *commit* фазы, React **синхронно** запускает *lifecycle* методы ```componentDidMount()```, ```componentDidUpdate()```, и хук ```useLayoutEffect()```. И затем **асинхронно** хук ```useEffect()```.

## Render output

Рендер использует функцию ```React.createElement()```, которая возвращает js объект, описывающий представление компонента:

```javascript
// JSX синтаксис:
return <SomeComponent a={42} b="testing">Text here</SomeComponent>

// конвертируется в вызов функции:
return React.createElement(SomeComponent, {a: 42, b: "testing"}, "Text Here")

// на выходе получается js объект:
// {type: SomeComponent, props: {a: 42, b: "testing"}, children: ["Text Here"]}
```

## Re-render

После первичного рендеринга и отображения приложения в DOM дереве, повторный рендер может быть вызван по одной из следующих причин.

Для классовых компонентов:

+ ```this.setState()```
+ ```this.forceUpdate()```

Для функциональных компонентов:

+ ```useState```
+ ```useReducer```

Для всех:

+ Рендер родителя вызовет рендер всех его дочерних элементов (стандартное поведение, но возможна оптимизация)
+ повторный рендеринг будет вызван, если повторно запустить ```ReactDOM.render(<App />)```, что эквивалентно ```forceUpdate()``` на корневом компоненте.

## Рендер дочерних компонентов

> По умолчанию, если рендерится родительский компонент, то все его дочерние компоненты будут перерендерены, даже если их *props* не изменились.

Рендер *"дешевая"* операция, по сравнению с обновлением DOM дерева. Если, выполняя рендер, React увидит, что текущий результат рендера совпадает с предыдущим, то обновление DOM не произойдет (фаза *commit* будет пропущена). Но процесс рендеринга и сравнения (фазы *render* и *reconciliation*) тоже занимают некоторое время, и в ряде случаев можно пропустить их для оптимизации производительности.

## Оптимизиция

> Оптимизация рендеринга заключается в том, чтобы не делать его без необходимости.

Для предотвращения лишнего рендера могут быть использованы:

+ ```React.Component.shouldComponentUpdate``` &mdash; метод жизненного цикла классового компонента, если он вернет ```false``` то рендер не будет запущен.
+ ```React.PureComponent``` &mdash; класс, реализующий типовой ```shouldComponentUpdate```.
+ ```React.memo()``` &mdash; *HOC*, который предотвращает повторный рендер, если входные *props* не изменились

> Используйте ```React.memo()``` на родительском компоненте, чтобы остановить каскадный рендер всех дочерних компонентов.

Мемоизация тоже имеет свою цену и применять ее следует при необходимости. По этой причине, стандартно, React компоненты не мемоизированы.

## Ссылки в props

Стандартные методы оптимизации сравниваются объекты и функции в *props* как ссылки, и если ссылка меняется, то произойдет рендер, даже если новый объект эквивалентен предыдущему:

```js
const MemoizedChildComponent = React.memo(ChildComponent)

function ParentComponent() {
    const onClick = () => {
      console.log("Button clicked")
    }
    
    const data = {a: 1, b: 2}
    
    return <MemoizedChildComponent onClick={onClick} data={data} />
}
```

Любой рендер ```<ParentComponent />``` вызовет рендер ```<MemoizedChildComponent />```. Причина в том, что при рендере ```<ParentComponent />```, функция ```onClick```будет создаваться заново. Для того, чтобы это предотвратить, нужно использовать специальные методы, которые сохраняют ссылки на неизменные объекты между рендерами.

Данная особенность касается функциональных компонентов, так как экземпляр классового компонента и ссылки на его методы находятся в памяти и не меняются.

Избегайте **случайной** инициализации объекта или функции непосредственно в *props*, это является распространенной ошибкой:

```js
<ComponentA style={{color: red}}/>
<ComponentB onClick={() => {}}/>
```

## Мемоизация ссылок

Чтобы в функциональном компоненте сохранить ссылки на объекты между рендерами, используйте хуки:

+ ```useMemo()```
+ ```useCallback()```

```js
const MemoizedChildComponent = React.memo(ChildComponent)

function ParentComponent() {
    const onClick = useCallback(() => {
      console.log("Button clicked")
    }, [])
    
    const data = useMemo(() => ({a: 1, b: 2}), [])
    
    return <MemoizedChildComponent onClick={onClick} data={data} />
}
```

Хуки ```useMemo()``` и ```useCallback()``` принимают вторым аргументом массив зависимостей. Изменение зависимостей приведет к перерасчету значения, которое возвращает хук.

## Профилирование

> Не производите замер производительности в develop режиме, только в production сборке.

Полезные статьи по профилированию производительности:
+ [React DevTools Profiler](https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html)
+ [a special "profiling" build of React](https://kentcdodds.com/blog/profile-a-react-app-for-performance)

## Контекст (Context)

> React's Context API обеспечивает передачу переменных в дерево компонентов, без их непосредственной передачи в *props* данных компонентов.

*Context* не является стейт-менеджером. Вы должны сами управлять значениями, которые передаются в *Контекст*. Обычно это достигается созданием компонента со стейтом, который устанавливает из него переменные *Контекста*.

## Context API

Создание *Контекста*:

```js
<MyContext.Provider value={42}>
  // ...
</MyContext.Provider>
```

Потребитель *Контекста*:

```js
<MyContext.Consumer>
    {(value) => <div>{value}</div>}
</MyContext.Consumer>
````

Для функциональных компонентов хук:

```js
const value = useContext(MyContext)
```

## Обновление Контекста

Если значение *Контекст* обновлено, то все компоненты, которые его используют, будут перерендерены. Нет способа это изменить.

Если в *Контекст* передан массив, или объект, то при его изменении, будут перерендерен каждый компонент, использующий данный *Контекст*. Даже если изменилась только часть объекта, которую непосредственно этот компонент не использует. 

Следует помнить, что рендер родительского компонента, вызывает рендер всех его дочерних компонентов, по этому:

> Компонент, который находится под *Context Provider*, почти гарантированно должен использовать **React.memo**.

Далее рассмотрим сценарий обновления компонентов, использующих мемоизацию и *Контекст*. 

## Контекст и мемоизация

```js
function GreatGrandchildComponent() {
  return <div>Hi</div>
}

function GrandchildComponent() {
    const value = useContext(MyContext);
    return (
      <div>
        {value.a}
        <GreatGrandchildComponent />
      </div>
    )
}

function ChildComponent() {
    return <GrandchildComponent />
}

const MemoizedChildComponent = React.memo(ChildComponent);

function ParentComponent() {
    const [a, setA] = useState(0);
    const [b, setB] = useState("text");

    const contextValue = {a, b};

    return (
      <MyContext.Provider value={contextValue}>
        <MemoizedChildComponent />
      </MyContext.Provider>
    )
}
```

Если выполнить ```setA(42)``` произойдет следующее:
 
1. Рендер ```ParentComponent```
2. Создается ссылка на ```contextValue```
3. React понимает, что MyContext.Provider получил новое значение и его потребителей нужно обновить.
4. React попытается рендерить ```MemoizedChildComponent```, который обернут в React.memo. Так как свойства не изменились, то сработает мемоизация и React не станет повторно рендерить ```ChildComponent```.
5. Тем не менее, обновился MyContext.Provider, и могут быть компоненты ниже по дереву, которые его используют.
React продолжит обход и увидит ```GrandchildComponent```. ```GrandchildComponent``` использует контекст, и так как контекст обновился, React перерендерит GrandchildComponent.
6. Так как ```GrandchildComponent``` рендерится, React двигается дальше и рендерит все, что в нем находится. Таким образом, React повторно рендерит ```GreatGrandchildComponent```.
 
## React-Redux и Context
 
>*Redux* и *Контекст* &mdash; разные инструменты и делают разную работу.

Несмотря на то, что *Redux* использует *Контекст*, имеются существенные отличия. *Redux* передает в *Контекст* экземпляр хранилища, ссылка на экземпляр всегда неизменна. Таким образом, React не обновляет компоненты при изменении значений в хранилище стандартным способом. Логикой обновления компонентов занимается непосредственно модуль, связывающий React и Redux.
 
Обновление происходит за счет того, что *UI компоненты*, подключенные к *Redux*, подписываются на изменение хранилища. Когда меняется значение в хранилище, для каждого подписчика вызывается *callback*, сравнивающий старое и новое значение релевантное для данного подписчика, которое используется в его ```mapState()``` или ```useSelector()```. Если значение изменилось, то для данного компонента форсированно выполняется рендер.

> *Контекст*, при изменении значения в *провайдере*, вызывает рендер для каждого компонента. *Redux* вызывает рендер только для тех компонентов, которые непосредственно используют измененные значения. Но при использовании Redux, для каждого компонента запускается *селектор* и сравниваются значения.

Обычно реализация в ```Redux``` (запуск селекторов, сравнение старого и нового значения, рендеринг если значение изменилось) работает быстрее, чем стандартная реализация на *Контексте* (полный перерендер дерева). Но при наличии сложных вычислений в селекторах, или если селекторы случайно возвращают новую ссылку, возможна потеря производительности.

## Connect и useSelector

> Используйте ```React.memo()``` в компонентах с ```useSelector()```, чтобы остановить нежелательную нисходящую последовательность рендеров. При использовании ```connect()``` React сделает это за вас.

Функция **```connect()```** создает *HOC*, который подписывает компонент на изменение хранилища, выполняет работу по ```mapState()```, ```mapDispatch()```, передает комбинированные свойства в компонент и контролирует, чтобы рендер вызывался при изменении свойств, на которые подписан компонент, а не при изменении любого свойства в хранилище.

```connect()``` *HOC* предотвращает повторный рендеринг, аналогично ```PureComponent``` и ```React.memo()```, если входные свойства не изменились. Но стоит помнить, что помимо собственных свойств, сюда добавляется ```mapState()```, и если он возвратит новую ссылку, то это вызовет рендер.

Свойства, которые передаются *HOC'ом* в компонент, формируются по такому принципу:

```{...ownProps, ...stateProps, ...dispatchProps}```

Хук **```useSelector()```** запускается внутри функционального компонента и не имеет возможности остановить рендер данного компонента, если рендерится его родительский компонент.

## Общие выводы

+ По умолчанию, React рендерит все дочерние компоненты, при рендере родительского
+ В рендеринге нет ничего плохого, часто нет смысла его предотвращать
+ Рендер может замедлять UI, в таком случае есть смысл его предотвращать, например, с помощью ```React.memo()```
+ ```React.memo()``` не сможет предотвратить рендер, если компонент получает новую ссылку в *props*
+ Нет ничего плохого в том, чтобы передавать новую ссылку в *props*, если рендер родительского компонента предполагает рендер дочернего (мемоизация дочернего компонента в таком случае не нужна)
+ Контекст распространяет значение на любую глубину вложенности, без его передачи в *props*
+ Контекст проверяет значение по ссылке, так он узнает, что значение изменилось
+ Новое значение контекста заставит всех его потребителей выполнить рендер (и, соответственно, рендер всех их дочерних компонентов тоже)
+ Часто есть смысл обернуть в ```React.memo()``` дочерний компонент у провайдера Контекста.
+ *React-Redux* использует подписки, вместо передачи новых значений в *Контекст*
+ Подписки выполняются на каждом изменении хранилища, по этому, они должны быть максимально быстрыми
+ *React-Redux* делает много работы, чтобы вычислить, для каких компонентов должен быть выполнен форсированный рендер
+ ```connect()``` действует как ```React.memo()```
+ ```useSelector()``` это хук, и он не может блокировать рендер, если произошел рендер в родительском компоненте, в отличие от ```connect```
+ Если все ваши компоненты используют ```useSelector()```, оберните некоторые из них в ```React.memo()```, чтобы избежать лишних рендеров в данных деревьях компонентов.