---
title: Композиция промисов
seoDescription: Композиция промисов в JavaScript.
seoKeywords: js, промисы, promise, compose, композиция
date: 2019-09-16 04:00:00
---

# Композиция промисов

Функция может вернуть промис, назовем такую функцию &ndash; фабрикой промисов. Как и <a href="/conspect/lang/js/composing-software/composition/">обычные синхронные функции</a>, фабрики промисов можно композировать, хотя реализация будет отличаться.

Композировать будем через ```compose```. Принцип ```compose```, похож на ```pipe```, с той разницей, что композиция выполняется справа налево, а в случае с ```pipe``` она выполнялась бы слева направо. 

Рассмотрим сначала синхронный вариант:

```js
const composeSync = (...funcs) => value => 
  funcs.reduceRight((accum, func) => func(accum), value);

const minusOne = n => n - 1;
const addTwo = n => n + 2;
const multipleTwo = n => n * 2;
const calc = composeSync(minusOne, addTwo, multipleTwo);
calc(2) // 5
```

Обратите внимание на ```reduceRight```, если бы вместо него мы использовали ```reduce```, то получили бы ```pipe```.

Как работает ```composeSync```. Тут все просто, хотя сначала может показаться запутанным. ```composeSync``` это функция, которая принимает некоторые синхронные функции, и возвращает функцию, которая принимает аргумент и возвращает результат работы редьюсера, который аккумулирует результаты переданных в начале функций начиная с указанного аргумента справа налево.

Теперь перейдем к сути. Compose для фабрик промисов:

```js
const composePromises = (...promiseFabrics) => (
  promiseFabrics.reduce((f, g) => value => g(value).then(f));
);
```

Интересно, что в отличие от синхронного примера выше, ```composePromises``` не возвращает функцию, которая возвращает редьюсер. Вместо этого, сразу возвращается результат работы редьюсера. Магия в том, что этот редьюсер возвращает функцию, а не переменную. 

Из-за асинхронной природы промисов, для построения композиционной цепочки недостаточно просто передать результат выполнения в последующую функцию, как это было с синхронными функциями в примере выше. Вместо этого, редьюсер на каждом шаге возвращает функцию, которая выполняет промис текущего шага и через ```then``` отложенно запускает функцию, полученную на предыдущем шаге редьюсера.

Если вы дочитали до этого места, то рассмотрим пример и потом разберем подробнее, как он работает:

```js
const composePromises = (...promiseFabrics) => (
  promiseFabrics.reduce((f, g) => value => g(value).then(f))
);

const minusOne = n => Promise.resolve(n - 1);
const addTwo = n => Promise.resolve(n + 2);
const multipleTwo = n => Promise.resolve(n * 2);

const calculate = composePromises(minusOne, addTwo, multipleTwo);

calculate(2).then(console.log); // 5
```

Что происходит в редьюсере? Для лучшего понимания процесса разложим его работу по шагам:

```js
const step1 = n => Promise.resolve(n - 1).then(undefined);
const step2 = n => Promise.resolve(n + 2).then(step1);
const step3 = n => Promise.resolve(n * 2).then(step2);
step3(2).then(console.log); // 5
```

Фактически, после объединения шагов, мы получим что-то такое: 

```js
const calculate = n => Promise
  .resolve(n * 2)
  .then(
    n => Promise.resolve(n + 2).then(
      n => Promise.resolve(n - 1).then(
        undefined
      )
    )
  )

calculate(2).then(console.log); // 5
```

Вас могло удивить, что в ```then``` первого шага передается ```undefined```. Это происходит от того, что в редьюсере не задано начальное значение. Но *промисы* в *JavaScript* устроены так, что они просто "проглотят" любое значение, кроме функции, как будто ничего не было. По этому, в данном случае это скорее фича, а не баг. Например:  

```js
Promise.resolve(10)
  .then(55) // будет пропущено, так как не является коллбеком
  .then(n => n + 1)
  .then(console.log) // 11
```

На этом, статью про композицию промисов можно закончить. Из-за моих дополнительных комментариев и примеров, получилось больше текста, чем ожидал. Надеюсь, это было полезно :tada:
