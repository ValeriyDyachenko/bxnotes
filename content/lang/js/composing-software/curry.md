---
title:  Каррирование, частичное применение
description: каррирование и частичное применение в JavaScript.
keywords: каррирование, частичное применение
date: 2020-06-02 00:00:00
---

> Функциональное программирование полностью основано на объединении крошечных функций в высокоуровневые абстракции.

**Каррирование** и **частичное применение**, являются важной частью *функционального программирования*. Они помогают создавать абстракции и переиспользовать существующий код.

## Что такое каррирование?

*Каррированная функция* - это функция, которая может принимать несколько аргументов, но по одному за раз. Способность принимать по одному аргументу за раз, называется *унарностью*. *Унарность*, это обязательное свойство *каррированных функций*.

## Что такое частичное применение?

*Частичное применение* - это функция, которая принимает за раз столько аргументов, сколько пожелает, но не все. 

> Все каррированные функции возвращают частичное применение, для хранения введенных аргументов.

## Простой пример каррирования

```js
const add = x => y => x + y;
const inc10 = add(10);
const inc20 = add(20);

inc10(3); // => 13
inc20(3); // => 23
```

## generic map + частичное применение

[Предыдущая глава](https://bxnotes.ru/conspect/lang/js/composing-software/functors/) рассказывает о функторах. Но что, если вы хотите **generic map**, который работает с любым функтором? Реализовать данную абстракцию поможет каррирование.

```javascript

// вариант функции каррирования (но помните, 
// если передается больше 1 аргумента за раз, это частичное применение) 
const curry = (f, arr = []) => (...args) => (
  a => a.length === f.length ?
  f(...a) :
  curry(f, a)
)([...arr, ...args]);

// Эта функция работает так:
// const add3 = curry((a, b, c) => a + b + c);
// add3(1, 2, 3); // 6
// add3(1, 2)(3); // 6
// add3(1)(2, 3); // 6
// add3(1)(2)(3); // 6

// функтор
const Identity = value => ({
  map: fn => Identity(fn(value))
});

const log = x => console.log(x);
const double = n => n * 2;

const map = curry((fn, mappable) => mappable.map(fn));
const mdouble = map(double);

// работает с функтором
mdouble(Identity(4)).map(log); // 8

// работает с массивом
mdouble([4]).map(log); // 8
```
