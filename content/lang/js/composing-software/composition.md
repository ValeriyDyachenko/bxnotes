---
title:  Функциональная композиция
description: Композиция в JavaScript?
keywords: js, composition
date: 2019-07-11 00:00:00
---

> Композиция &ndash; суть разработки софта.

Композиция функций &ndash; это способ получить новую функцию из уже имеющихся, с помощью их объединения.

Для функциональной композиции принято использовать инструменты абстракции ```pipe()``` и ```compose()```. Они делают код декларативным, программист описывает результат, а не реализацию.

Рассмотрим разницу между декларативной и императивной композицией подробнее. Допустим, есть 2 простых функции:

```js
const g = n => n + 1;
const f = n => n * 2;
```

Мы хотим объединить их в одну функцию, чтобы к числу сначала прибавлялась единица, а потом полученный результат умножался на 2.

Императивное описание функции выглядело бы так:

```js
const doImperative = x => {
  const afterG = g(x);
  return f(afterG);
};

doImperative(20); // 42
```

Декларативный стиль вместо этого предлагает использовать вспомогательную функцию ```pipe()```. Ее реализуют многие популярные библиотеки, такие как **lodash**, но на самом деле ее примитивная реализация достаточно проста, и поместится в одну строку кода: 

```js
const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x);
```

Теперь, с функцией ```pipe()```, пример выше можно переписать на декларативный манер:

```js
const doDeclarative = pipe(g, f)

doDeclarative(20); // 42
```

Разница между подходами становится еще более очевидной при усложнении задачи. Добавим логирование после каждого шага с помощью функции:

```js
const trace = message => value => {
  console.log(`${message}: ${value}`);
  return value;
}
```

Императивный стиль:

```js
const doImperative = x => {
  const afterG = g(x);
  trace('after g')(afterG);
  const afterF = f(afterG);
  trace('after f')(afterF);
  return afterF;
};

doImperative(20); 
```

Декларативный стиль:

```js
const doDeclarative = pipe(g, trace('after g'), f, trace('after f'));
doDeclarative(20);
```

В методе ```doDeclarative()``` нет хранения промежуточного результата в переменных, вместо этого, результат предыдущей функции передается в следующую. За это отвечает функция ```pipe```.

Интересно, что цепочка промисов тоже является композицией:

```js
Promise.resolve(20)
  .then(g)
  .then(trace('after g'))
  .then(f)
  .then(trace('after f'))
```

Каждый последующий блок ```then``` принимает результат предыдущего и передает последующему. Очень похоже на рассмотренный ранее ```pipe```, не правда ли?