---
layout: post.njk
tags: [post, postInConspect:git-intro, postInSubject:git, postInSection:util]
conspect: git-intro
section: util
subject: git
title: Базовые команды
seoDescription: Описание основных команд, необходимых для работы с Git.
seoKeywords: git, commands, cli
date: 2018-05-08 02:00:00
---
# Базовые команды

## Настройка

```
git config user.name "Username"
git config user.email "username@somemail.com"
```

Флаг `-global` добавленный к командам выше позволит сохранить эти настройки для всех проектов: 

```
git config --global user.name ‘Username’
git config --global user.email ‘username@somemail.com’
```

Чтобы использовать *VS CODE* как редактор по умолчанию, запустите команду:

```
git config --global core.editor "code --wait"
```

Для того, чтобы использовать *VS CODE* как *difftool* запустите команду:

```
git config --global -e
```

И добавьте строки:

```
[diff]
    tool = vscode
[difftool "vscode"]
    cmd = code --wait --diff $LOCAL $REMOTE
```

## Справка по команде

`git help [command-name]`

Если вы используете *VS Code*, как редактор по умолчанию, то установите расширение *open in browser*, чтобы открывать документацию в браузере.

## Инициализация проекта

Для начала работы зайдите в вашем терминале в директорию, в которой собираетесь использовать *Git* и выполните команду `git init`, вы увидите сообщение похожее на это:

```        
D:\webdev\git\first-use>git init
Initialized empty Git repository in D:/webdev/git/first-use/.git/
```       
    
Данная команда создала скрытую директорию `.git`, в этой директории будут храниться версии файлов и с помощью неё обеспечивается весь связанный с контролем версий функционал.

## Add

```
git add [filename]
```

Добавляет выбранные версии файлов в *staging* область для последующего коммита.

```
git add .
```

Добавляет все файлы в очередь для последующего коммита.

## Commit

```
git commit -m "this is comment"
```

Создает коммит с комментарием после ключа `-m`. Предварительно должны быть указанны с помощью `git add` файлы.

```
git commit -am "this is another comment"
```

Если не указать файлы командой `git add`, то команда `git commit` не создаст *коммит*. Эти два действия можно объединить, указав ключ `-a`. Данный ключ показывает, что нужно создать коммит всех измененных файлов, учитывая удаленные, но при этом новые файлы (которых еще нет в индексе) учитываться не будут.

## Pull и Push

Рассмотрим команды `pull` и `push` на практическом примере. Создадим на гитхабе новый тестовый проект. Поставьте галочку чтобы создать readme файл:

![создание GitHub проекта](/assets/img/util/git/git-intro/bazovye-komandy/init-git-project.png "создание GitHub проекта")

Затем создадим директорию, инициализируем в ней *Git*, и выполним команды `remote add` и `pull`:

```
mkdir test-project
cd test-project
git init
git remote add origin https://github.com/ValeriyDyachenko/test-project
git pull origin master
```

Таким образом мы создали директорию и инициализировали в ней локальный репозиторий. С помощью команды `remote add origin` при привязали локальный репозиторий к удаленному. А с помощью команды `git pull origin master` были скопированы файлы (в данном случае файл readme) с удаленного репозитория на локальный из ветки `origin master`.

Теперь откроем файл `README.md` из локальной директории, добавим туда что-нибудь и выполним следующие команды:

```
git add .
git commit -m "test push"
git push origin master        
```

Система запросит указать имя пользователя и пароль. После успешной авторизации изменения будут загружены на удаленный репозиторий в указанную ветку.

Подведем итог:

+ `git push` — добавляет данные на удаленный сервер с локального компьютера
+ `git pull` — забирает данные на локальный компьютер с удаленного сервера

## Clone

Клонирование существующего репозитория осуществляется с помощью команды `git clone <url>`, например:

```
git clone https://github.com/libgit2/libgit2 
```

Предыдущая команда создаст репозиторий в директории `libgit2`. Для клонирование в директорию с другим именем:

```
git clone https://github.com/libgit2/libgit2 newname
```

Команду `clone` можно использовать как короткий вариант, заменяющий серию команд:

```
mkdir test-project
cd test-project
git init
git remote add origin https://github.com/ValeriyDyachenko/test-project
git pull origin master 
``` 

## Branch

Ветви позволяют работать одновременно над несколькими версиями репозитория.

По умолчания, после создания проекта в нем присутствует единственная ветвь *master*. С помощью ветвей вы можете вносить свои вариации и правки, тестировать их, а потом объединять с главной ветвью.

Когда вы создаете новую ветвь, создается копия *master* ветви. В процессе работы над своей ветвью, ветвь *master* может обновиться кем-то. В таком случае, вы можете забрать эти изменения в свою ветвь, с помощью команды `pull`.

Создать ветвь:

```
git branch newbranch
```

Перейти в ветвь:

```
git checkout newbranch
```

Создать ветвь и сразу же в неё перейти:

```
git checkout -b newbranch
```

Если нужно загрузить новую ветвь на сервер, выполните команду:

```
git push origin newbranch
```

Допустим, вы внесли все изменения в созданную ветвь, протестировали их, и теперь хотите объединить эту ветвь с основной. Для этого запустите следующие команды (и затем выполните push запрос):

```
git checkout master
git merge newbranch
```

Когда ветви объединены и изменения перенесены в основную ветку, вам больше не нужна дополнительная ветвь. Для того, чтобы удалить её, перейдите в другую ветвь и выполните команду:

```
git branch -d newbranch 
```

Это удалит ветвь из локального репозитория. Для удаления ветви из удаленного репозитория выполните команду: 

```
git push -d origin newbranch
```

## Просмотр старых версий проекта

Если возникла необходимость посмотреть как выглядел тот или иной файл в определенный момент развития проекта, то сделать это очень просто.

Посмотрите лог и скопируйте *id* интересующего коммита: 

```
git log
```

Затем выполните команду `checkout` для данного коммита, например:

```
git checkout bc9f07bbadb153d88a4daa3bd21aafe054b15055
```

С этого момента рабочая область проекта изменится и вы можете работать с этими версиями файлами. При необходимости, можно создать новую ветку с помощью рассмотренной ранее команды:

```
git checkout -b [your-new-branch-name]
```

Для того, чтобы вернуться к последней версии коммита из главной ветки, напишите команду:

```
git checkout master
```

Обратите внимание, что когда вы находитесь в предыдущей версии коммита с помощью команды `checkout`, то команда `git log` покажет лог только до текущего коммита, в котором вы находитесь. Чтобы увидеть все коммиты воспользуйтесь командой `git reflog`.

Есть возможность перейти к определенной версии проекта, удалив при этом последующие коммиты. Но этот вариант не рекомендуется, так как изменения будут потеряны:

```
git reset --hard [commit-id]
```

## Status

Посмотреть текущую ветку, незакоммиченные файлы и другую информацию:

```
git status
```

## Stash

Используйте команду `git stash`, чтобы сохранить рабочую область и индекс без применения коммита и вернуться к чистой рабочей директории. Это может пригодиться, если работа еще не закончена и рано вносить изменения на проект.

Просмотреть стек спрятанных данных можно с помощью команды `git stash list`. Дополнительные данные покажет команда `git stash show`.

Строка вида *stash@{0}*, отображаемая при выполнении команды `git stash list` - это номер сохраненных изменений в стеке, по которому можно эти данные восстановить или удалить.

Для восстановления данных есть команда `git stash apply`, если запустить её без параметров, будет восстановлена рабочая область последнего в стеке сохранения. Чтобы восстановить конкретный номер в стеке укажите его: `git stash apply stash@{0}` или с помощью сокращенного варианта `git stash apply 0`.

Команда `git stash pop` применяет спрятанные изменения и удаляет их из стека.

Команда `git stash drop [stash-name]` удаляет указанную заначку, или последнюю, если номер явно не указан.

## Дополнительно

Для получения подробной информации по командам смотрите их описание на [официальном сайте](https://git-scm.com/docs/).